load dalekosaur/object.mat

patch('vertices', Xo', 'faces', Faces, 'facecolor', 'w', 'edgecolor', 'k');
axis vis3d;
axis equal;
xlabel('Xo-axis'); ylabel('Yo-axis'); zlabel('Zo-axis');

ObjectDirectory = 'dalekosaur';
InputImage = imread("InputImage1.png");

  
[impoints2D, objpoints3D] = clickPoints( InputImage, ObjectDirectory );
%% New section
figure;
imshow(InputImage); hold on;
plot( impoints2D(:,1), impoints2D(:,2), 'b.');

    figure;
patch('vertices', Xo', 'faces', Faces, 'facecolor', 'w', 'edgecolor', 'k');
axis vis3d;
axis equal;
plot3( objpoints3D(:,1), objpoints3D(:,2), objpoints3D(:,3), 'b.' );


%% Estimate camera projection matrix M, estimate K,R,t
M = estimateCameraProjectionMatrix(impoints2D, objpoints3D);

A = M(:, 1:3);
b = M(:, 4);
C = A*transpose(A);

lambda = 1 / sqrt(C(3,3));
lambdasq = lambda * lambda;
xc = lambdasq * C(1, 3);
yc = lambdasq * C(2, 3);

fy = sqrt(abs(lambdasq*C(2,2) - yc.^2));
alpha = (1 / fy)*((xc.^2)*C(1,2) - xc*yc);
fx = sqrt(abs(lambdasq * C(1,1) - alpha.^2 - xc.^2));

K = [fx alpha xc; 0 fy yc; 0 0 1];

R = transpose(K) * A / sqrt(C(3,3));
if det(R) ~= 1
    R = -R;
    lambda = -lambda;
end
t = lambda * transpose(K) * b;

%% Verify

estim = zeros(size(impoints2D, 1), 2);
for i = 1:(size(estim, 1))
    homog = M * [objpoints3D(i,1); objpoints3D(i,2); objpoints3D(i,3); 1];
    estim(i, :) = homog(1:2) ./ homog(3);
end

imshow("InputImage1.png");
hold on;

plot(estim(:, 1), estim(:, 2), 'ro', 'MarkerSize', 10)

hold off;

%% Part 3
% Auto-generated by cameraCalibrator app on 24-Apr-2024
%-------------------------------------------------------


% Define images to process
imageFileNames = {'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7300.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7301.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7302.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7303.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7304.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7305.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7306.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7307.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7309.jpg',...
    'C:\Users\trevo\Documents\MATLAB\Computer Vision\Assignment 3\Images\IMG_7310.jpeg',...
    };
% Detect calibration pattern in images
detector = vision.calibration.monocular.CheckerboardDetector();
[imagePoints, imagesUsed] = detectPatternPoints(detector, imageFileNames);
imageFileNames = imageFileNames(imagesUsed);

% Read the first image to obtain image size
originalImage = imread(imageFileNames{1});
[mrows, ncols, ~] = size(originalImage);

% Generate world coordinates for the planar pattern keypoints
squareSize = 3.810000e+01;  % in units of 'millimeters'
worldPoints = generateWorldPoints(detector, 'SquareSize', squareSize);

% Calibrate the camera
[cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', false, 'EstimateTangentialDistortion', false, ...
    'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'millimeters', ...
    'InitialIntrinsicMatrix', [], 'InitialRadialDistortion', [], ...
    'ImageSize', [mrows, ncols]);

% View reprojection errors
h1=figure; showReprojectionErrors(cameraParams);

% Visualize pattern locations
h2=figure; showExtrinsics(cameraParams, 'CameraCentric');

% Display parameter estimation errors
displayErrors(estimationErrors, cameraParams);

% For example, you can use the calibration data to remove effects of lens distortion.
undistortedImage = undistortImage(originalImage, cameraParams);

% See additional examples of how to use the calibration data.  At the prompt type:
% showdemo('MeasuringPlanarObjectsExample')
% showdemo('StructureFromMotionExample')
%% Estimate Transform
function A = estimateCameraProjectionMatrix( im_points, obj_points )

%creating matrix 
P = zeros(size(im_points, 1) * 2, 11);
r = zeros(1, 2*size(im_points, 1));
%filling matrix with values of points derived via linear equations. 
for i = 1:(size(im_points, 1))
    P(i*2 - 1, :) = [-obj_points(i, 1) -obj_points(i, 2) -obj_points(i, 3) -1 0 0 0 0 im_points(i, 1)*obj_points(i,1) im_points(i, 1)*obj_points(i,2) im_points(i,1)*obj_points(i,3)];
    P(i*2, :) = [0 0 0 0 -obj_points(i, 1) -obj_points(i, 2) -obj_points(i, 3) -1 im_points(i, 2)*obj_points(i, 1) im_points(i, 2)*obj_points(i,2) im_points(i,2)*obj_points(i,3)];
    r(2*i-1) = -im_points(i, 1);
    r(2*i) = -im_points(i, 2);

end

q = inv(P'*P)*P'*r';
q(12, 1) = 1;

%returning homography values
A = (reshape(q, 4, 3))';
end

function Transform_Image = transform_Image( input_image, transform_matrix, transform_type )
    input_image = im2double(input_image);
    input_image = im2gray(input_image);

    [h,w] = size(input_image);
    corners = [1 w w 1; 1 1 h h; 1 1 1 1];

    corners = transform_matrix * corners;
    
    xlocations = round(corners(1,:)./corners(3,:));
    ylocations = round(corners(2,:)./corners(3,:));


    xmin = 1;
    xmax = max(xlocations);

    ymin = 1;
    ymax = max(ylocations);

    display_size = [xmax - xmin + 1, ymax - ymin + 1];

    [X,Y] = meshgrid( xmin:xmax, ymin:ymax );
    coords = [X(:)';Y(:)';];
    coords = [coords(1,:);coords(2,:);ones(1, display_size(1)*display_size(2));];

    if (strcmp(transform_type, "translate"))
        inverse = transform_matrix;
        inverse(1,3)= -inverse(1,3);
        inverse(2,3)= -inverse(2,3);

     elseif (strcmp(transform_type, "rotate"))
        inverse = transform_matrix;
        inverse(1,2)= -inverse(1,2);
        inverse(2,1)= -inverse(2,1);

     elseif (strcmp(transform_type, "reflect"))
        inverse = transform_matrix;

    elseif (strcmp(transform_type, "shear"))
        inverse = transform_matrix;
        inverse(1,2)= -inverse(1,2);
        inverse(2,1)= -inverse(2,1);
   
     else 
        inverse = inv(transform_matrix);

     end
    sample_pos = inverse * coords;

    x = sample_pos(1,:)./sample_pos(3,:);
    y = sample_pos(2,:)./sample_pos(3,:);

   x = reshape( x', display_size(2), display_size(1));
   y = reshape( y', display_size(2), display_size(1));

    Transform_Image = interp2( input_image, x, y );
    
   
end